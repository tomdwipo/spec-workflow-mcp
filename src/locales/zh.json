{
  "tools": {
    "steeringGuide": {
      "description": "加载创建项目指导文档的指南。\n\n# 使用说明\n仅在用户明确请求创建指导文档或询问项目架构文档时调用。不是标准规范工作流的一部分。为 product.md、tech.md 和 structure.md 的创建提供模板和指导。",
      "successMessage": "指导工作流指南已加载 - 请严格遵循此工作流",
      "dashboardMessage": "仪表板：{{dashboardUrl}}",
      "dashboardUnavailable": "仪表板不可用",
      "nextSteps": {
        "proceedIfRequested": "仅在用户请求指导文档时继续",
        "createProduct": "首先创建 product.md",
        "createTechAndStructure": "然后创建 tech.md 和 structure.md",
        "reference": "在未来的规范中引用"
      },
      "guide": "# 指导工作流\n\n## 概述\n\n在明确请求时创建项目级别的指导文档。指导文档为已建立的代码库确立愿景、架构和约定。\n\n## 工作流图表\n\n```mermaid\nflowchart TD\n    Start([开始：设置指导文档]) --> Guide[steering-guide<br/>加载工作流说明]\n    \n    %% 阶段 1：产品\n    Guide --> P1_Template[get-template-context<br/>templateType: steering<br/>template: product]\n    P1_Template --> P1_Generate[生成愿景和目标]\n    P1_Generate --> P1_Create[create-steering-doc<br/>document: product]\n    P1_Create --> P1_Approve[request-approval<br/>仅 filePath]\n    P1_Approve --> P1_Status[get-approval-status<br/>轮询状态]\n    P1_Status --> P1_Check{状态？}\n    P1_Check -->|needs-revision| P1_Update[使用用户评论作为指导更新文档]\n    P1_Update --> P1_Create\n    P1_Check -->|approved| P1_Clean[delete-approval]\n    P1_Clean -->|failed| P1_Status\n    \n    %% 阶段 2：技术\n    P1_Clean -->|success| P2_Template[get-template-context<br/>templateType: steering<br/>template: tech]\n    P2_Template --> P2_Analyze[分析技术栈]\n    P2_Analyze --> P2_Create[create-steering-doc<br/>document: tech]\n    P2_Create --> P2_Approve[request-approval<br/>仅 filePath]\n    P2_Approve --> P2_Status[get-approval-status<br/>轮询状态]\n    P2_Status --> P2_Check{状态？}\n    P2_Check -->|needs-revision| P2_Update[使用用户评论作为指导更新文档]\n    P2_Update --> P2_Create\n    P2_Check -->|approved| P2_Clean[delete-approval]\n    P2_Clean -->|failed| P2_Status\n    \n    %% 阶段 3：结构\n    P2_Clean -->|success| P3_Template[get-template-context<br/>templateType: steering<br/>template: structure]\n    P3_Template --> P3_Analyze[分析代码库结构]\n    P3_Analyze --> P3_Create[create-steering-doc<br/>document: structure]\n    P3_Create --> P3_Approve[request-approval<br/>仅 filePath]\n    P3_Approve --> P3_Status[get-approval-status<br/>轮询状态]\n    P3_Status --> P3_Check{状态？}\n    P3_Check -->|needs-revision| P3_Update[使用用户评论作为指导更新文档]\n    P3_Update --> P3_Create\n    P3_Check -->|approved| P3_Clean[delete-approval]\n    P3_Clean -->|failed| P3_Status\n    \n    P3_Clean -->|success| Complete([指导文档完成])\n    \n    style Start fill:#e6f3ff\n    style Complete fill:#e6f3ff\n    style P1_Check fill:#ffe6e6\n    style P2_Check fill:#ffe6e6\n    style P3_Check fill:#ffe6e6\n```\n\n## 指导工作流阶段\n\n### 阶段 1：产品文档\n**目的**：定义愿景、目标和用户结果。\n\n**工具**：\n- steering-guide：加载工作流说明\n- get-template-context：加载产品模板（templateType: \"steering\", template: \"product\"）\n- create-steering-doc：创建 product.md\n- request-approval：获取用户批准\n- get-approval-status：检查批准状态\n- delete-approval：批准后清理\n\n**流程**：\n1. 为工作流概述加载指导指南\n2. 加载产品模板\n3. 生成产品愿景和目标\n4. 使用 create-steering-doc 创建文档\n5. 请求批准（仅 filePath）\n6. 轮询状态直到 approved/needs-revision（永远不要接受口头批准）\n7. 如果 needs-revision：更新文档，创建新批准，不要继续\n8. 一旦批准：在继续前 delete-approval（必须成功）\n9. 如果 delete-approval 失败：停止 - 返回轮询\n\n### 阶段 2：技术文档\n**目的**：记录技术决策和架构。\n\n**工具**：\n- get-template-context：加载技术模板（templateType: \"steering\", template: \"tech\"）\n- create-steering-doc：创建 tech.md\n- request-approval：获取用户批准\n- get-approval-status：检查状态\n- delete-approval：清理\n\n**流程**：\n1. 加载技术模板\n2. 分析现有技术栈\n3. 记录架构决策和模式\n4. 创建文档并请求批准\n5. 轮询状态直到 approved/needs-revision\n6. 如果 needs-revision：更新文档，创建新批准，不要继续\n7. 一旦批准：在继续前 delete-approval（必须成功）\n8. 如果 delete-approval 失败：停止 - 返回轮询\n\n### 阶段 3：结构文档\n**目的**：映射代码库组织和模式。\n\n**工具**：\n- get-template-context：加载结构模板（templateType: \"steering\", template: \"structure\"）\n- create-steering-doc：创建 structure.md\n- request-approval：获取用户批准\n- get-approval-status：检查状态\n- delete-approval：清理\n\n**流程**：\n1. 加载结构模板\n2. 分析目录结构和文件组织\n3. 记录编码模式和约定\n4. 创建文档并请求批准\n5. 轮询状态直到 approved/needs-revision\n6. 如果 needs-revision：更新文档，创建新批准，不要继续\n7. 一旦批准：在继续前 delete-approval（必须成功）\n8. 如果 delete-approval 失败：停止 - 返回轮询\n9. 成功清理后：\"指导文档完成。准备好创建规范了吗？\"\n\n## 工作流规则\n\n- 始终使用 MCP 工具，永远不要手动创建文档\n- 遵循确切的模板结构\n- 在阶段之间获得明确的用户批准\n- 按顺序完成阶段（不跳过）\n- 批准请求：仅提供 filePath，永远不要提供内容\n- 阻塞：如果 delete-approval 失败，永远不要继续\n- 关键：在下一阶段之前必须有批准状态和成功的清理\n- 关键：永远不接受口头批准 - 仅限仪表板或 VS Code 扩展\n- 永远不要在用户说\"已批准\"时继续 - 仅检查系统状态"
    },
    "specStatus": {
      "description": "显示全面的规范进度概览。\n\n# 使用说明\n在恢复规范工作或检查整体完成状态时调用。显示哪些阶段已完成和任务实施进度。在继续工作流之前了解您在哪里很有用。",
      "projectPathDescription": "项目根目录的绝对路径",
      "specNameDescription": "规范名称",
      "successMessage": "规范 '{{specName}}' 状态：{{overallStatus}}",
      "phases": {
        "requirements": "需求",
        "design": "设计",
        "tasks": "任务",
        "implementation": "实施"
      },
      "nextSteps": {
        "requirements": {
          "create": "创建 requirements.md",
          "loadContext": "使用 get-steering-context 加载上下文",
          "requestApproval": "请求批准"
        },
        "design": {
          "create": "创建 design.md",
          "reference": "参考需求",
          "requestApproval": "请求批准"
        },
        "tasks": {
          "create": "创建 tasks.md",
          "breakdown": "分解设计",
          "requestApproval": "请求批准"
        },
        "implementation": {
          "nextPending": "使用 manage-tasks 和 next-pending",
          "implement": "实施任务",
          "updateStatus": "使用 manage-tasks 更新状态",
          "begin": "使用 manage-tasks 开始实施"
        },
        "completed": {
          "complete": "规范完成",
          "runTests": "运行测试"
        }
      },
      "errors": {
        "notFound": "未找到规范 '{{specName}}'",
        "genericFail": "获取规范状态失败：{{message}}",
        "nextSteps": {
          "checkName": "检查规范名称",
          "useList": "使用 spec-list 查看可用规范",
          "create": "使用 create-spec-doc 创建规范",
          "checkExists": "检查规范是否存在",
          "verifyPath": "验证项目路径",
          "useListGeneric": "使用 spec-list 查看可用规范"
        }
      }
    },
    "specList": {
      "description": "列出项目中的所有规范。\n\n# 使用说明\n在选择要处理的规范之前调用以查看可用规范。显示每个规范的状态，包括阶段完成情况。对于选择要实施或继续工作的规范很有用。",
      "projectPathDescription": "项目根目录的绝对路径",
      "successMessage_one": "找到 {{count}} 个规范",
      "successMessage_other": "找到 {{count}} 个规范",
      "messages": {
        "noSpecs": "未找到规范"
      },
      "nextSteps": {
        "noSpecs": {
          "create": "使用 spec-create 创建新规范",
          "example": "示例：spec-create user-authentication \"用户登录和注册\""
        },
        "success": {
          "viewStatus": "使用 spec-status <name> 查看特定规范的详细状态",
          "continue": "使用 spec-execute <task-id> <name> 继续实施",
          "create": "使用 spec-create 创建新规范"
        }
      },
      "errors": {
        "failed": "列出规范失败：{{message}}",
        "nextSteps": {
          "checkPath": "检查项目路径是否存在",
          "verifyDir": "验证 .spec-workflow 目录是否存在",
          "create": "如果不存在则使用 spec-create 创建规范"
        }
      }
    },
    "requestApproval": {
      "description": "通过仪表板界面请求用户批准。\n\n# 使用说明\n在创建每个文档后立即调用。在进入下一阶段之前必需。关键：仅提供 filePath 参数 - 仪表板直接读取文件。永远不要在请求中包含文档内容。在继续之前等待用户审查和批准。",
      "projectPathDescription": "项目根目录的绝对路径",
      "titleDescription": "描述需要批准的内容的简短标题",
      "filePathDescription": "需要批准的文件路径（相对于项目根目录）。仪表板将读取并显示此文件。",
      "typeDescription": "批准请求类型 - \"document\" 用于内容批准，\"action\" 用于行动批准",
      "categoryDescription": "批准请求类别 - \"spec\" 用于规范，\"steering\" 用于指导文档",
      "categoryNameDescription": "规范名称或指导文档的 \"steering\"",
      "successMessage": "批准请求创建成功。请在仪表板中审查：{{dashboardUrl}}",
      "dashboardUnavailable": "仪表板 URL 不可用",
      "nextSteps": {
        "blocking": "阻塞 - 需要仪表板或 VS Code 扩展批准",
        "noVerbal": "不接受口头批准",
        "noVerbalConfirm": "不要在口头确认时继续",
        "useDashboard": "使用仪表板：{{dashboardUrl}} 或 VS Code 扩展",
        "useVscode": "使用 VS Code 扩展进行批准",
        "poll": "使用以下方式轮询状态：get-approval-status \"{{approvalId}}\""
      },
      "errors": {
        "failed": "创建批准请求失败：{{message}}"
      }
    },
    "refreshTasks": {
      "description": "基于当前需求和设计重新生成任务列表。\n\n# 使用说明\n在设计更改后需要更新任务或弥合实施和需求之间的差距时调用。分析现有的 requirements.md 和 design.md 以创建全面的更新任务列表。用刷新版本替换现有的 tasks.md。",
      "projectPathDescription": "项目根目录的绝对路径",
      "specNameDescription": "规范名称",
      "successMessage": "为 \"{{specName}}\" 加载的任务刷新上下文。准备好让 AI 代理分析和更新任务。",
      "analysis": {
        "hasTasks": "\n## 当前任务分析\n**总任务数**：{{total}}\n**已完成**：{{completed}}（保持原样，即使功能被移除）\n**进行中**：{{inProgress}}（保持原样，即使功能被移除）\n**待处理**：{{pending}}（必须对照 requirements.md/design.md 验证）\n\n### 要保留的任务（不要修改）：\n{{completedList}}\n{{inProgressList}}\n\n### 待处理任务（必须验证）：\n{{pendingList}}\n\n**需要验证**：对于上面每个待处理任务，验证功能是否在 requirements.md 或 design.md 中提及。如果未提及，删除任务。\n",
        "noTasks": "\n## 当前任务分析\n**不存在 tasks.md** - 您需要从头开始创建完整的任务列表。\n",
        "none": "无",
        "checkPrompt": "检查：此功能在 requirements.md 中吗？"
      },
      "instructions": {
        "main": "# 任务刷新说明\n\n## 上下文\n您正在刷新规范 \"{{specName}}\" 的任务列表，因为在实施过程中需求或设计可能已经改变。您的目标是确保任务列表准确反映弥合当前实施和更新的需求/设计之间差距所需完成的工作。\n\n## 关键：真实来源\n- **需求仅来自 requirements.md** - 不是来自现有任务\n- **设计决策仅来自 design.md** - 不是来自现有任务\n- **任务是实施步骤** - 它们实施需求，不定义需求\n- 如果任务中存在功能但 requirements.md/design.md 中不存在，则该功能已从规范中移除\n\n## 三轮验证流程\n\n### 第一轮：根据当前规范验证现有任务\n对于每个现有任务，问：\"此任务实施的功能是否仍在 requirements.md 或 design.md 中？\"\n\n**待处理任务的操作：**\n- **保留**：如果功能仍在需求/设计中\n- **移除**：如果功能不在需求/设计中（功能已从规范中删除）\n\n**已完成/进行中任务的操作：**\n- **保留**：始终保留已完成 [x] 和进行中 [-] 任务\n- **标记**：如果功能被移除，添加注释：\"_注意：功能已从规范中移除但任务已保留_\"\n\n### 第二轮：差距分析\n对于 requirements.md 中的每个需求，问：\"是否有实施此需求的任务？\"\n对于 design.md 中的每个设计决策，问：\"是否有与此架构对齐的任务？\"\n\n**操作：**\n- **添加**：为没有任务的需求/设计元素添加新任务\n- **更新**：需要与更新需求对齐的现有待处理任务\n\n### 第三轮：创建更新任务列表（仅在需要更改时）\n**决策点**：第一轮和第二轮后，检查：\n- 是否有待处理任务需要移除？\n- 是否有新任务需要添加？\n- 是否有现有任务需要修改？\n\n**如果不需要更改**：报告 \"任务列表已与当前需求对齐 - 无需刷新\" 并停止。\n\n**如果需要更改**，构建新的 tasks.md：\n1. 所有已完成 [x] 任务（保持原样）\n2. 所有进行中 [-] 任务（保持原样，如适用则带有移除注释）\n3. 仅在当前需求/设计中有支持的待处理 [ ] 任务\n4. 任何缺失需求/设计元素的新任务\n5. 正确的排序和需求引用\n\n## 关键规则\n- **永远不要**修改已完成任务（标记为 [x]）\n- **永远不要**修改进行中任务（标记为 [-]）\n- **移除**当前需求/设计中没有功能的待处理任务\n- **始终**引用特定需求（例如，_需求：1.1, 2.3_）\n- **确保**任务逐步构建\n- **使**任务原子化、具体和可行\n- **保留**原始 tasks.md 结构 - 仅更新任务项本身\n- **不要**在 tasks.md 中添加其他部分（无依赖关系、指标、注释、更改记录等）\n- **保持** tasks.md 清洁 - 任何更改摘要仅在您的聊天响应中\n\n## 任务格式要求\n每个任务必须遵循此格式：\n```\n- [ ] 1.1 创建用户认证接口\n  - 文件：src/auth/UserAuth.ts\n  - 实施登录和注册表单\n  - 添加表单验证和错误处理\n  - 目的：启用用户账户管理\n  - _利用：src/components/BaseForm.tsx, src/utils/validation.ts_\n  - _需求：1.1, 1.2_\n```\n\n## 实施策略\n1. **阅读** requirements.md 和 design.md 仔细 - 这些定义应该存在什么\n2. **验证**现有任务与当前规范（第一轮）\n3. **识别**任务覆盖中的差距（第二轮）\n4. **构建**具有适当验证的更新任务列表（第三轮）\n5. **使用** create-spec-doc 工具保存更新的 tasks.md\n6. **重要**：保持 tasks.md 与原始格式相同 - 仅任务项应更改\n\n## 示例：处理移除的功能\n如果任务存在于 \"看板视图\"，但 requirements.md 中未提及 \"看板视图\"：\n- **移除**任何待处理 [ ] 看板任务\n- **保留**任何已完成 [x] 或进行中 [-] 看板任务\n- **添加注释**：\"_注意：看板功能已从规范中移除但已完成的工作已保留_\"\n\n## 下一步\n分析下面的文档后：\n1. 执行三轮验证流程\n2. **决策点**：如果验证后不需要更改，只需报告 \"任务已对齐\" 并停止\n3. **仅在需要更改时**：使用 create-spec-doc 工具：\n   - projectPath: \"{{projectPath}}\"\n   - specName: \"{{specName}}\"\n   - document: \"tasks\"\n   - content: [您验证和更新的任务标记 - 与原始格式相同]\n4. 确保仅当前需求有任务\n5. 验证任务依赖关系和顺序有意义\n6. **记住**：Tasks.md 应该仅包含更新的任务列表 - 无额外部分"
      },
      "fullContext": "{{instructions}}\n\n{{taskAnalysis}}\n\n---\n\n## 需求文档\n{{requirementsContent}}\n\n---\n\n## 设计文档\n{{designContent}}\n\n---\n\n## 当前任务文档\n{{tasksContent}}\n\n---\n\n## 摘要\n您现在拥有刷新任务列表所需的所有上下文。使用 create-spec-doc 工具创建更新的 tasks.md：\n- 保留所有已完成（[x]）和进行中（[-]）任务（即使功能已被移除）\n- 移除当前 requirements.md/design.md 中没有功能的待处理（[ ]）任务\n- 为缺少任务的需求/设计元素添加新任务\n- 确保正确的任务排序和需求引用\n- 仅包括实际在 requirements.md/design.md 中指定的功能的任务\n\n**记住**：如果任务中存在功能但 requirements.md/design.md 中不存在，则已从规范中删除，待处理任务应被移除。",
      "messages": {
        "noRequirements": "未找到 requirements.md",
        "noDesign": "未找到 design.md",
        "noTasks": "不存在 tasks.md - 从头开始创建"
      },
      "nextSteps": {
        "pass1": "第一轮：根据 requirements.md/design.md 验证每个现有任务",
        "pass2": "第二轮：识别差距 - 找到没有任务的需求/设计元素",
        "decision": "决策：如果不需要更改，报告 \"任务已对齐\" 并停止",
        "pass3": "第三轮：仅在需要更改时，使用 create-spec-doc 工具创建更新的 tasks.md"
      },
      "errors": {
        "noContext": "未找到 requirements.md 或 design.md。没有规范上下文无法刷新任务。",
        "genericFail": "加载刷新上下文失败：{{message}}",
        "nextSteps": {
          "createReq": "首先使用 create-spec-doc 工具创建 requirements.md",
          "createDesign": "需求批准后创建 design.md",
          "thenRefresh": "然后使用 refresh-tasks 创建对齐的任务列表",
          "checkDir": "检查规范目录是否存在",
          "checkPerms": "验证文件权限",
          "checkName": "确保规范名称正确"
        }
      }
    },
    "getTemplateContext": {
      "description": "为规范或指导文档加载特定文档模板。\n\n# 使用说明\n使用当前阶段所需的确切模板调用。对于规范工作流，请求需求、设计或任务模板。对于指导文档，请求产品、技术或结构模板。每个模板提供 create-spec-doc 或 create-steering-doc 工具期望的确切格式。",
      "projectPathDescription": "项目根目录的绝对路径",
      "templateTypeDescription": "模板类型：spec 用于工作流模板，steering 用于项目文档",
      "templateDescription": "要加载的特定模板",
      "docTitles": {
        "requirements": "需求模板",
        "design": "设计模板",
        "tasks": "任务模板",
        "product": "产品模板",
        "tech": "技术模板",
        "structure": "结构模板"
      },
      "successMessage": "为 {{templateType}} 加载 {{template}} 模板",
      "messages": {
        "fullContext": "## {{title}}\n\n{{content}}\n\n**注意**：模板已加载。创建 {{template}} 文档时使用此结构。"
      },
      "nextSteps": {
        "success": {
          "useTemplate": "将模板用于 {{template}} 文档",
          "followStructure": "严格遵循模板结构",
          "nextSpec": "下一步：create-spec-doc，document: \"{{template}}\"",
          "nextSteering": "下一步：create-steering-doc，document: \"{{template}}\""
        }
      },
      "errors": {
        "invalidType": "无效的模板类型：{{templateType}}",
        "validTypes": "使用：spec 或 steering",
        "invalidTemplateForType": "类型 \"{{templateType}}\" 的无效模板 \"{{template}}\"",
        "validTemplates": "有效模板：{{validTemplates}}",
        "validSpecTemplates": "使用：requirements、design 或 tasks",
        "validSteeringTemplates": "使用：product、tech 或 structure",
        "templateEmpty": "模板文件存在但为空：{{file}}",
        "fileNotFound": "未找到模板文件：{{file}}",
        "genericFail": "加载模板上下文失败：{{message}}",
        "nextSteps": {
          "checkContent": "检查模板文件内容",
          "verifyIntegrity": "验证文件完整性",
          "checkDirectory": "检查模板目录",
          "verifyExists": "验证模板文件是否存在",
          "location": "位置：{{location}}",
          "checkPermissions": "验证文件权限",
          "checkFiles": "检查模板文件"
        }
      }
    },
    "getSteeringContext": {
      "description": "为架构和产品上下文加载项目指导文档。\n\n# 使用说明\n在初始规范设置期间调用以检查现有项目指南（product.md、tech.md、structure.md）。对于新项目可选，但建议用于已建立的代码库。如果不存在指导文档，询问用户是否先创建它们或继续规范。",
      "projectPathDescription": "项目根目录的绝对路径",
      "docTitles": {
        "product": "产品上下文",
        "tech": "技术上下文",
        "structure": "结构上下文"
      },
      "successMessage": "指导上下文加载成功",
      "messages": {
        "notFound": "未找到指导文档",
        "notFoundContext": "## 指导文档上下文\n\n未找到指导文档。使用检测到的技术栈的最佳实践继续。",
        "emptyDocs": "指导文档存在但为空",
        "emptyContext": "## 指导文档上下文\n\n找到指导文档但都为空。",
        "fullContext": "## 指导文档上下文（预加载）\n\n{{sections}}\n\n**注意**：指导文档已预加载。不要再次使用 get-content 获取它们。"
      },
      "nextSteps": {
        "notFound": {
          "useBestPractices": "为检测到的技术栈使用最佳实践和约定",
          "askToCreate": "对于已建立的代码库：询问用户是否要创建指导文档以获得项目特定的指导",
          "newProjectNote": "对于新项目：通常不需要指导上下文 - 使用技术最佳实践继续"
        },
        "empty": {
          "useBestPractices": "为技术栈使用最佳实践和约定",
          "askToPopulate": "对于已建立的代码库：询问用户是否要用项目特定上下文填充指导文档",
          "newProjectNote": "对于新项目：空的指导文档没关系 - 使用标准实践继续"
        },
        "success": {
          "doNotCallAgain": "指导上下文已加载 - 不要再次调用 get-steering-context",
          "reference": "在需求、设计和任务中引用这些标准",
          "align": "确保所有决策与记录的项目愿景一致"
        }
      },
      "errors": {
        "genericFail": "加载指导上下文失败：{{message}}",
        "nextSteps": {
          "checkPath": "检查项目路径是否存在",
          "checkPermissions": "验证文件权限",
          "runSetup": "如果缺少指导文档，运行 spec-steering-setup"
        }
      }
    },
    "getSpecContext": {
      "description": "为恢复工作加载现有规范文档。\n\n# 使用说明\n仅在休息后返回现有规范工作或对您未创建的规范进行新工作时调用。如果您刚创建了文档，永远不要在活跃规范创建期间使用。为实施上下文加载 requirements.md、design.md 和 tasks.md。",
      "projectPathDescription": "项目根目录的绝对路径",
      "specNameDescription": "要加载上下文的规范名称",
      "docTitles": {
        "requirements": "需求",
        "design": "设计",
        "tasks": "任务"
      },
      "successMessage": "规范上下文加载成功：{{specName}}",
      "messages": {
        "emptyDocs": "\"{{specName}}\" 的规范文档存在但为空",
        "emptyContext": "## 规范上下文\n\n未找到规范文档：{{specName}}",
        "fullContext": "## 规范上下文（预加载）：{{specName}}\n\n{{sections}}\n\n**注意**：规范文档已预加载。不要再次使用 get-content 获取它们。"
      },
      "nextSteps": {
        "empty": {
          "addContent": "将内容添加到 .spec-workflow/specs/{{specName}}/",
          "createMissing": "创建缺失的文档",
          "ensureContent": "确保所有三个文档都有内容"
        },
        "success": {
          "proceed": "上下文已加载 - 继续实施",
          "reference": "为每个任务引用需求和设计",
          "updateStatus": "使用 manage-tasks 更新任务状态"
        }
      },
      "errors": {
        "notFound": "未找到规范：{{specName}}",
        "availableSpecs": "可用规范：{{specs}}",
        "genericFail": "加载规范上下文失败：{{message}}",
        "nextSteps": {
          "useExisting": "使用现有规范名称",
          "createNew": "或使用 create-spec-doc 创建新的",
          "create": "使用 create-spec-doc 创建规范",
          "checkSpelling": "检查规范名称拼写",
          "verifySetup": "验证项目设置",
          "checkPath": "检查项目路径",
          "verifyName": "验证规范名称",
          "checkPermissions": "检查文件权限",
          "createIfMissing": "如果缺失则创建规范"
        }
      }
    },
    "getApprovalStatus": {
      "description": "检查批准请求的当前状态。\n\n# 使用说明\n在 request-approval 后调用以轮询用户决策。继续检查直到状态为 \"approved\" 或 \"needs-revision\"。如果 needs-revision，审查反馈，使用 create-spec-doc 更新文档，然后创建新的批准请求。仅在 \"approved\" 状态后继续下一阶段。",
      "projectPathDescription": "项目根目录的绝对路径（可选 - 如未提供将使用上下文）",
      "approvalIdDescription": "要检查的批准请求的 ID",
      "messages": {
        "pending": "阻塞：状态为 {{status}}。不接受口头批准。仅使用仪表板或 VS Code 扩展。",
        "other": "批准状态：{{status}}"
      },
      "nextSteps": {
        "pending": {
          "blocked": "阻塞 - 不要继续",
          "noVerbal": "不接受口头批准 - 仅使用仪表板或 VS Code 扩展",
          "useUI": "必须通过仪表板或 VS Code 扩展进行批准",
          "poll": "继续使用 get-approval-status 轮询"
        },
        "approved": {
          "canProceed": "已批准 - 可以继续",
          "delete": "继续前运行 delete-approval",
          "response": "响应：{{response}}"
        },
        "rejected": {
          "blocked": "阻塞 - 已拒绝",
          "doNotProceed": "不要继续",
          "revise": "审查反馈并修订",
          "reason": "原因：{{reason}}",
          "notes": "注释：{{notes}}"
        },
        "needsRevision": {
          "blocked": "阻塞 - 不要继续",
          "update": "使用反馈更新文档",
          "newRequest": "创建新的批准请求",
          "feedback": "反馈：{{feedback}}",
          "notes": "注释：{{notes}}",
          "comments": "{{count}} 个评论用于目标修复"
        }
      },
      "errors": {
        "projectPathRequired": "需要项目路径。请提供 projectPath 参数。",
        "notFound": "未找到批准请求：{{approvalId}}",
        "genericFail": "检查批准状态失败：{{message}}"
      }
    },
    "deleteApproval": {
      "description": "从系统中清理已完成的批准请求。\n\n# 使用说明\n在收到 \"approved\" 状态后立即调用。防止批准混乱的基本清理步骤。必须在进入下一个工作流阶段之前完成。保持批准系统对未来请求的组织。",
      "projectPathDescription": "项目根目录的绝对路径（可选 - 如未提供将使用上下文）",
      "approvalIdDescription": "要删除的批准请求的 ID",
      "successMessage": "批准请求 \"{{approvalId}}\" 删除成功",
      "nextSteps": {
        "cleanupComplete": "清理完成",
        "continue": "继续下一阶段"
      },
      "errors": {
        "projectPathRequired": "需要项目路径。请提供 projectPath 参数。",
        "notFound": "未找到批准请求 \"{{approvalId}}\"",
        "notApproved": "阻塞：无法继续 - 状态为 \"{{status}}\"。不接受口头批准。使用仪表板或 VS Code 扩展。",
        "deleteFailed": "删除批准请求 \"{{approvalId}}\" 失败",
        "genericFail": "删除批准失败：{{message}}",
        "nextSteps": {
          "verifyId": "验证批准 ID",
          "checkStatus": "使用 get-approval-status 检查状态",
          "stop": "停止 - 不要进入下一阶段",
          "wait": "等待批准",
          "poll": "使用 get-approval-status 轮询",
          "checkPermissions": "检查文件权限",
          "verifyExists": "验证批准是否存在",
          "retry": "重试",
          "checkPath": "检查项目路径",
          "checkSystem": "检查批准系统"
        }
      }
    },
    "createSteeringDoc": {
      "description": "创建带有架构指导的项目指导文档。\n\n# 使用说明\n仅在用户明确批准创建指导文档后调用。规范工作流不需要。创建以下之一：product.md（愿景/目标）、tech.md（技术决策）或 structure.md（代码库组织）。首先使用 steering-guide 获取模板。",
      "projectPathDescription": "项目根目录的绝对路径",
      "documentDescription": "要创建的指导文档：product、tech 或 structure",
      "contentDescription": "指导文档的完整 markdown 内容",
      "docNames": {
        "product": "产品指导",
        "tech": "技术指导",
        "structure": "结构指导"
      },
      "successMessage": "{{docName}} 文档创建成功",
      "nextSteps": {
        "saved": "已保存 {{filename}}",
        "product": "下一步：创建 tech.md",
        "tech": "下一步：创建 structure.md",
        "structure": "指导完成。使用 request-approval，category:\"steering\" 和 categoryName:\"steering\"",
        "dashboard": "仪表板：{{dashboardUrl}}",
        "dashboardUnavailable": "仪表板不可用"
      },
      "errors": {
        "failed": "创建 {{document}} 指导文档失败：{{message}}",
        "nextSteps": {
          "checkPath": "检查项目路径是否存在",
          "verifyContent": "验证 markdown 内容",
          "retry": "使用正确参数重试"
        }
      }
    },
    "createSpecDoc": {
      "description": "按工作流顺序创建或更新规范文档。\n\n# 使用说明\n在加载模板和为每个阶段生成内容后调用。一次创建一个文档：首先需求，然后设计，然后任务。永远不要在没有用户批准的情况下创建多个文档。始终遵循来自 get-template-context 的模板结构。",
      "projectPathDescription": "项目根目录的绝对路径",
      "specNameDescription": "kebab-case 格式的功能名称（例如，user-authentication）",
      "documentDescription": "要创建/更新的规范文档：requirements、design 或 tasks",
      "contentDescription": "规范文档的完整 markdown 内容",
      "errors": {
        "designBeforeReq": "工作流违规：在 requirements.md 存在之前无法创建 design.md！\n首先创建 requirements.md，获得用户审查，然后创建 design.md。",
        "tasksBeforeDesign": "工作流违规：在 design.md 存在之前无法创建 tasks.md！\n首先创建 design.md，获得用户审查，然后创建 tasks.md。",
        "failed": "失败：{{message}}"
      },
      "successMessage": "在：{{filePath}} 创建了 {{filename}}\n\n阻塞：必须通过仪表板或 VS Code 扩展请求批准。\n不接受口头批准。\n在系统显示批准状态之前不要继续。"
    },
    "specWorkflowGuide": {
      "description": "加载基本规范工作流说明以指导功能从想法到实施的开发。\n\n# 使用说明\n当用户请求规范创建、功能开发或提及规范时首先调用此工具。这提供必须遵循的完整工作流序列（需求 → 设计 → 任务 → 实施）。在任何其他规范工具之前始终加载以确保正确的工作流理解。",
      "dashboardMessage": "在仪表板上监控进度：{{dashboardUrl}}",
      "dashboardUnavailable": "仪表板不可用 - 以无头模式运行",
      "successMessage": "完整规范工作流指南已加载 - 严格遵循此工作流",
      "nextSteps": {
        "step1": "遵循序列：需求 → 设计 → 任务 → 实施",
        "step2": "首先使用 get-template-context 加载模板",
        "step3": "在每个文档后请求批准",
        "step4": "仅使用 MCP 工具"
      },
      "guide": "# 规范开发工作流\n\n## 概述\n\n您使用 MCP 工具指导用户完成规范驱动的开发。通过需求 → 设计 → 任务 → 实施阶段将粗略的想法转化为详细的规范。如果可用，使用网络搜索获取当前最佳实践。\n\n功能名称使用 kebab-case（例如，user-authentication）。一次创建一个规范。\n\n## 工作流图表\n```mermaid\nflowchart TD\n    Start([开始：用户请求功能]) --> CheckSteering{指导文档存在？}\n    CheckSteering -->|是| P1_Load[get-steering-context]\n    CheckSteering -->|否| P1_Template\n    \n    %% 阶段 1：需求\n    P1_Load --> P1_Template[get-template-context<br/>templateType: spec<br/>template: requirements]\n    P1_Template --> P1_Research[如果可用则进行网络搜索]\n    P1_Research --> P1_Create[create-spec-doc<br/>document: requirements]\n    P1_Create --> P1_Approve[request-approval<br/>仅 filePath]\n    P1_Approve --> P1_Status[get-approval-status<br/>轮询状态]\n    P1_Status --> P1_Check{状态？}\n    P1_Check -->|needs-revision| P1_Update[使用用户评论作为指导更新文档]\n    P1_Update --> P1_Create\n    P1_Check -->|approved| P1_Clean[delete-approval]\n    P1_Clean -->|failed| P1_Status\n    \n    %% 阶段 2：设计\n    P1_Clean -->|success| P2_Template[get-template-context<br/>templateType: spec<br/>template: design]\n    P2_Template --> P2_Analyze[分析代码库模式]\n    P2_Analyze --> P2_Create[create-spec-doc<br/>document: design]\n    P2_Create --> P2_Approve[request-approval<br/>仅 filePath]\n    P2_Approve --> P2_Status[get-approval-status<br/>轮询状态]\n    P2_Status --> P2_Check{状态？}\n    P2_Check -->|needs-revision| P2_Update[使用用户评论作为指导更新文档]\n    P2_Update --> P2_Create\n    P2_Check -->|approved| P1_Clean[delete-approval]\n    P2_Clean -->|failed| P2_Status\n    \n    %% 阶段 3：任务\n    P2_Clean -->|success| P3_Template[get-template-context<br/>templateType: spec<br/>template: tasks]\n    P3_Template --> P3_Break[将设计转换为任务]\n    P3_Break --> P3_Create[create-spec-doc<br/>document: tasks]\n    P3_Create --> P3_Approve[request-approval<br/>仅 filePath]\n    P3_Approve --> P3_Status[get-approval-status<br/>轮询状态]\n    P3_Status --> P3_Check{状态？}\n    P3_Check -->|needs-revision| P3_Update[使用用户评论作为指导更新文档]\n    P3_Update --> P3_Create\n    P3_Check -->|approved| P3_Clean[delete-approval]\n    P3_Clean -->|failed| P3_Status\n    \n    %% 阶段 4：实施\n    P3_Clean -->|success| P4_Ready[规范完成。<br/>准备好实施吗？]\n    P4_Ready -->|是| P4_Status[spec-status]\n    P4_Status --> P4_Task[manage-tasks<br/>action: set-status<br/>status: in-progress]\n    P4_Task --> P4_Code[实施代码]\n    P4_Code --> P4_Complete[manage-tasks<br/>action: set-status<br/>status: completed]\n    P4_Complete --> P4_More{更多任务？}\n    P4_More -->|是| P4_Task\n    P4_More -->|否| End([实施完成])\n    \n    style Start fill:#e1f5e1\n    style End fill:#e1f5e1\n    style P1_Check fill:#ffe6e6\n    style P2_Check fill:#ffe6e6\n    style P3_Check fill:#ffe6e6\n    style CheckSteering fill:#fff4e6\n    style P4_More fill:#fff4e6\n```\n\n## 规范工作流\n\n### 阶段 1：需求\n**目的**：根据用户需求定义要构建的内容。\n\n**工具**：\n- get-steering-context：检查项目指南（如果是已建立的代码库）\n- get-template-context：加载需求模板（templateType: \"spec\", template: \"requirements\"）\n- create-spec-doc：创建 requirements.md\n- request-approval：获得用户批准\n- get-approval-status：检查批准状态\n- delete-approval：批准后清理\n\n**流程**：\n1. 检查指导文档（询问用户是否要为已建立的代码库创建它们）\n2. 加载需求模板\n3. 研究市场/用户期望（如果网络搜索可用）\n4. 使用 EARS 标准生成用户故事需求\n5. 使用 create-spec-doc 创建文档\n6. 请求批准（仅 filePath，永远不要内容）\n7. 轮询状态直到 approved/needs-revision（永远不接受口头批准）\n8. 如果 needs-revision：更新文档，创建新批准，不要继续\n9. 一旦批准：在继续前 delete-approval（必须成功）\n10. 如果 delete-approval 失败：停止 - 返回轮询\n\n### 阶段 2：设计\n**目的**：创建解决所有需求的技术设计。\n\n**工具**：\n- get-template-context：加载设计模板（templateType: \"spec\", template: \"design\"）\n- create-spec-doc：创建 design.md\n- request-approval：获得用户批准\n- get-approval-status：检查状态\n- delete-approval：清理\n\n**流程**：\n1. 加载设计模板\n2. 分析代码库以重用模式\n3. 研究技术选择（如果网络搜索可用）\n4. 使用所有模板部分生成设计\n5. 创建文档并请求批准\n6. 轮询状态直到 approved/needs-revision\n7. 如果 needs-revision：更新文档，创建新批准，不要继续\n8. 一旦批准：在继续前 delete-approval（必须成功）\n9. 如果 delete-approval 失败：停止 - 返回轮询\n\n### 阶段 3：任务\n**目的**：将设计分解为原子实施任务。\n\n**工具**：\n- get-template-context：加载任务模板（templateType: \"spec\", template: \"tasks\"）\n- create-spec-doc：创建 tasks.md\n- request-approval：获得用户批准\n- get-approval-status：检查状态\n- delete-approval：清理\n\n**流程**：\n1. 加载任务模板\n2. 将设计转换为原子任务（每个 1-3 个文件）\n3. 包括文件路径和需求引用\n4. 创建文档并请求批准\n5. 轮询状态直到 approved/needs-revision\n6. 如果 needs-revision：更新文档，创建新批准，不要继续\n7. 一旦批准：在继续前 delete-approval（必须成功）\n8. 如果 delete-approval 失败：停止 - 返回轮询\n9. 成功清理后：\"规范完成。准备好实施了吗？\"\n\n### 阶段 4：实施\n**目的**：系统地执行任务。\n\n**工具**：\n- spec-status：检查整体进度\n- manage-tasks：跟踪和更新任务状态\n- get-spec-context：如果返回工作则加载规范\n\n**流程**：\n1. 使用 spec-status 检查当前状态\n2. 对于每个任务：\n   - manage-tasks action: \"set-status\", status: \"in-progress\"\n   - 实施代码\n   - manage-tasks action: \"set-status\", status: \"completed\"\n3. 继续直到所有任务完成\n\n## 工作流规则\n\n- 始终使用 MCP 工具，永远不手动创建文档\n- 遵循确切的模板结构\n- 在阶段之间获得明确的用户批准\n- 按顺序完成阶段（不跳过）\n- 一次一个规范\n- 规范名称使用 kebab-case\n- 批准请求：仅提供 filePath，永远不要内容\n- 阻塞：如果 delete-approval 失败永远不要继续\n- 关键：下一阶段前必须有批准状态和成功清理\n- 关键：永远不接受口头批准 - 仅限仪表板或 VS Code 扩展\n- 永远不要在用户说\"已批准\"时继续 - 仅检查系统状态\n- 指导文档是可选的 - 仅在明确请求时创建"
    }
  }
}