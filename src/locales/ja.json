{
  "tools": {
    "steeringGuide": {
      "description": "プロジェクトステアリングドキュメント作成のためのガイドを読み込みます。\n\n# 使用方法\nユーザーがステアリングドキュメントの作成を明示的に要求したとき、またはプロジェクトアーキテクチャドキュメントについて尋ねたときのみ呼び出します。標準仕様ワークフローの一部ではありません。product.md、tech.md、structure.mdの作成のためのテンプレートとガイダンスを提供します。",
      "successMessage": "ステアリングワークフローガイドが読み込まれました - このワークフローに正確に従ってください",
      "dashboardMessage": "ダッシュボード: {{dashboardUrl}}",
      "dashboardUnavailable": "ダッシュボードは利用できません",
      "nextSteps": {
        "proceedIfRequested": "ユーザーがステアリングドキュメントを要求した場合のみ続行",
        "createProduct": "最初にproduct.mdを作成",
        "createTechAndStructure": "次にtech.mdとstructure.mdを作成",
        "reference": "将来の仕様で参照"
      },
      "guide": "# ステアリングワークフロー\n\n## 概要\n\n明示的に要求されたときにプロジェクトレベルのガイダンスドキュメントを作成します。ステアリングドキュメントは確立されたコードベースのビジョン、アーキテクチャ、および規約を確立します。\n\n## ワークフロー図\n\n```mermaid\nflowchart TD\n    Start([開始: ステアリングドキュメントのセットアップ]) --> Guide[steering-guide<br/>ワークフロー指示の読み込み]\n    \n    %% フェーズ1: プロダクト\n    Guide --> P1_Template[get-template-context<br/>templateType: steering<br/>template: product]\n    P1_Template --> P1_Generate[ビジョンと目標の生成]\n    P1_Generate --> P1_Create[create-steering-doc<br/>document: product]\n    P1_Create --> P1_Approve[request-approval<br/>filePathのみ]\n    P1_Approve --> P1_Status[get-approval-status<br/>ステータスのポーリング]\n    P1_Status --> P1_Check{ステータス?}\n    P1_Check -->|needs-revision| P1_Update[ユーザーコメントをガイダンスとしてドキュメントを更新]\n    P1_Update --> P1_Create\n    P1_Check -->|approved| P1_Clean[delete-approval]\n    P1_Clean -->|failed| P1_Status\n    \n    %% フェーズ2: テクノロジー\n    P1_Clean -->|success| P2_Template[get-template-context<br/>templateType: steering<br/>template: tech]\n    P2_Template --> P2_Analyze[技術スタックの分析]\n    P2_Analyze --> P2_Create[create-steering-doc<br/>document: tech]\n    P2_Create --> P2_Approve[request-approval<br/>filePathのみ]\n    P2_Approve --> P2_Status[get-approval-status<br/>ステータスのポーリング]\n    P2_Status --> P2_Check{ステータス?}\n    P2_Check -->|needs-revision| P2_Update[ユーザーコメントをガイダンスとしてドキュメントを更新]\n    P2_Update --> P2_Create\n    P2_Check -->|approved| P2_Clean[delete-approval]\n    P2_Clean -->|failed| P2_Status\n    \n    %% フェーズ3: 構造\n    P2_Clean -->|success| P3_Template[get-template-context<br/>templateType: steering<br/>template: structure]\n    P3_Template --> P3_Analyze[コードベース構造の分析]\n    P3_Analyze --> P3_Create[create-steering-doc<br/>document: structure]\n    P3_Create --> P3_Approve[request-approval<br/>filePathのみ]\n    P3_Approve --> P3_Status[get-approval-status<br/>ステータスのポーリング]\n    P3_Status --> P3_Check{ステータス?}\n    P3_Check -->|needs-revision| P3_Update[ユーザーコメントをガイダンスとしてドキュメントを更新]\n    P3_Update --> P3_Create\n    P3_Check -->|approved| P3_Clean[delete-approval]\n    P3_Clean -->|failed| P3_Status\n    \n    P3_Clean -->|success| Complete([ステアリングドキュメント完了])\n    \n    style Start fill:#e6f3ff\n    style Complete fill:#e6f3ff\n    style P1_Check fill:#ffe6e6\n    style P2_Check fill:#ffe6e6\n    style P3_Check fill:#ffe6e6\n```\n\n## ステアリングワークフローのフェーズ\n\n### フェーズ1: プロダクトドキュメント\n**目的**: ビジョン、目標、ユーザー成果を定義します。\n\n**ツール**:\n- steering-guide: ワークフロー指示の読み込み\n- get-template-context: プロダクトテンプレートの読み込み (templateType: \"steering\", template: \"product\")\n- create-steering-doc: product.mdの作成\n- request-approval: ユーザー承認の取得\n- get-approval-status: 承認ステータスの確認\n- delete-approval: 承認後のクリーンアップ\n\n**プロセス**:\n1. ワークフロー概要のステアリングガイドを読み込む\n2. プロダクトテンプレートを読み込む\n3. プロダクトビジョンと目標を生成\n4. create-steering-docでドキュメントを作成\n5. 承認をリクエスト（filePathのみ）\n6. approved/needs-revisionまでステータスをポーリング（口頭での承認は決して受け入れない）\n7. needs-revisionの場合: ドキュメントを更新し、新しい承認を作成し、続行しない\n8. 承認されたら: 続行前にdelete-approval（成功しなければならない）\n9. delete-approvalが失敗した場合: 停止 - ポーリングに戻る\n\n### フェーズ2: テクノロジードキュメント\n**目的**: 技術的決定とアーキテクチャを文書化します。\n\n**ツール**:\n- get-template-context: テクノロジーテンプレートの読み込み (templateType: \"steering\", template: \"tech\")\n- create-steering-doc: tech.mdの作成\n- request-approval: ユーザー承認の取得\n- get-approval-status: ステータスの確認\n- delete-approval: クリーンアップ\n\n**プロセス**:\n1. テクノロジーテンプレートを読み込む\n2. 既存の技術スタックを分析\n3. アーキテクチャの決定とパターンを文書化\n4. ドキュメントを作成し承認をリクエスト\n5. approved/needs-revisionまでステータスをポーリング\n6. needs-revisionの場合: ドキュメントを更新し、新しい承認を作成し、続行しない\n7. 承認されたら: 続行前にdelete-approval（成功しなければならない）\n8. delete-approvalが失敗した場合: 停止 - ポーリングに戻る\n\n### フェーズ3: 構造ドキュメント\n**目的**: コードベースの組織とパターンをマッピングします。\n\n**ツール**:\n- get-template-context: 構造テンプレートの読み込み (templateType: \"steering\", template: \"structure\")\n- create-steering-doc: structure.mdの作成\n- request-approval: ユーザー承認の取得\n- get-approval-status: ステータスの確認\n- delete-approval: クリーンアップ\n\n**プロセス**:\n1. 構造テンプレートを読み込む\n2. ディレクトリ構造とファイル組織を分析\n3. コーディングパターンと規約を文書化\n4. ドキュメントを作成し承認をリクエスト\n5. approved/needs-revisionまでステータスをポーリング\n6. needs-revisionの場合: ドキュメントを更新し、新しい承認を作成し、続行しない\n7. 承認されたら: 続行前にdelete-approval（成功しなければならない）\n8. delete-approvalが失敗した場合: 停止 - ポーリングに戻る\n9. クリーンアップ成功後: 「ステアリングドキュメント完了。仕様作成の準備はできましたか？」\n\n## ワークフロールール\n\n- 常にMCPツールを使用し、手動でドキュメントを作成しない\n- 正確なテンプレート構造に従う\n- フェーズ間で明示的なユーザー承認を取得\n- フェーズを順番に完了（スキップなし）\n- 承認リクエスト: filePathのみを提供し、コンテンツは決して含めない\n- ブロッキング: delete-approvalが失敗した場合は決して続行しない\n- 重要: 次のフェーズの前に承認ステータスと成功したクリーンアップが必要\n- 重要: 口頭での承認は決して受け入れられない - ダッシュボードまたはVS Code拡張機能のみ\n- ユーザーが「承認」と言っても決して続行しない - システムステータスのみを確認"
    },
    "specStatus": {
      "description": "包括的な仕様進捗概要を表示します。\n\n# 使用方法\n仕様の作業を再開するときや全体的な完了ステータスを確認するときに呼び出します。どのフェーズが完了していて、タスク実装の進捗を表示します。続行前にワークフローのどこにいるかを理解するのに便利です。",
      "projectPathDescription": "プロジェクトルートへの絶対パス",
      "specNameDescription": "仕様の名前",
      "successMessage": "仕様 '{{specName}}' のステータス: {{overallStatus}}",
      "phases": {
        "requirements": "要件",
        "design": "設計",
        "tasks": "タスク",
        "implementation": "実装"
      },
      "nextSteps": {
        "requirements": {
          "create": "requirements.mdを作成",
          "loadContext": "get-steering-contextでコンテキストを読み込む",
          "requestApproval": "承認をリクエスト"
        },
        "design": {
          "create": "design.mdを作成",
          "reference": "要件を参照",
          "requestApproval": "承認をリクエスト"
        },
        "tasks": {
          "create": "tasks.mdを作成",
          "breakdown": "設計を分解",
          "requestApproval": "承認をリクエスト"
        },
        "implementation": {
          "nextPending": "next-pendingでmanage-tasksを使用",
          "implement": "タスクを実装",
          "updateStatus": "manage-tasksでステータスを更新",
          "begin": "manage-tasksで実装を開始"
        },
        "completed": {
          "complete": "仕様完了",
          "runTests": "テストを実行"
        }
      },
      "errors": {
        "notFound": "仕様 '{{specName}}' が見つかりません",
        "genericFail": "仕様ステータスの取得に失敗しました: {{message}}",
        "nextSteps": {
          "checkName": "仕様名を確認",
          "useList": "利用可能な仕様はspec-listを使用",
          "create": "create-spec-docで仕様を作成",
          "checkExists": "仕様が存在するか確認",
          "verifyPath": "プロジェクトパスを確認",
          "useListGeneric": "spec-listを使用して利用可能な仕様を表示"
        }
      }
    },
    "specList": {
      "description": "プロジェクト内のすべての仕様をリストします。\n\n# 使用方法\n作業する仕様を選択する前に利用可能な仕様を確認するために呼び出します。フェーズ完了を含む各仕様のステータスを表示します。実装する仕様や作業を続ける仕様を選択するのに便利です。",
      "projectPathDescription": "プロジェクトルートへの絶対パス",
      "successMessage_one": "{{count}}個の仕様が見つかりました",
      "successMessage_other": "{{count}}個の仕様が見つかりました",
      "messages": {
        "noSpecs": "仕様が見つかりません"
      },
      "nextSteps": {
        "noSpecs": {
          "create": "spec-createを使用して新しい仕様を作成",
          "example": "例: spec-create user-authentication \"ユーザーログインと登録\""
        },
        "success": {
          "viewStatus": "spec-status <name>を使用して特定の仕様の詳細ステータスを表示",
          "continue": "spec-execute <task-id> <name>を使用して実装を続行",
          "create": "spec-createで新しい仕様を作成"
        }
      },
      "errors": {
        "failed": "仕様のリストに失敗しました: {{message}}",
        "nextSteps": {
          "checkPath": "プロジェクトパスが存在するか確認",
          "verifyDir": ".spec-workflowディレクトリが存在するか確認",
          "create": "仕様が存在しない場合はspec-createを使用して作成"
        }
      }
    },
    "requestApproval": {
      "description": "ダッシュボードインターフェースを通じてユーザー承認をリクエストします。\n\n# 使用方法\n各ドキュメント作成後すぐに呼び出します。次のフェーズに進む前に必要です。重要: filePathパラメータのみを提供 - ダッシュボードはファイルを直接読み取ります。リクエストにドキュメントの内容を決して含めないでください。続行前にユーザーがレビューして承認するまで待ちます。",
      "projectPathDescription": "プロジェクトルートへの絶対パス",
      "titleDescription": "承認が必要なものを説明する簡潔なタイトル",
      "filePathDescription": "承認が必要なファイルへのパス（プロジェクトルートからの相対パス）。ダッシュボードはこのファイルを読み取って表示します。",
      "typeDescription": "承認リクエストのタイプ - コンテンツ承認の場合は\"document\"、アクション承認の場合は\"action\"",
      "categoryDescription": "承認リクエストのカテゴリ - 仕様の場合は\"spec\"、ステアリングドキュメントの場合は\"steering\"",
      "categoryNameDescription": "仕様の名前またはステアリングドキュメントの場合は\"steering\"",
      "successMessage": "承認リクエストが正常に作成されました。ダッシュボードでレビューしてください: {{dashboardUrl}}",
      "dashboardUnavailable": "ダッシュボードURLは利用できません",
      "nextSteps": {
        "blocking": "ブロッキング - ダッシュボードまたはVS Code拡張機能での承認が必要",
        "noVerbal": "口頭での承認は受け入れられません",
        "noVerbalConfirm": "口頭での確認で続行しないでください",
        "useDashboard": "ダッシュボードを使用: {{dashboardUrl}} またはVS Code拡張機能",
        "useVscode": "承認にはVS Code拡張機能を使用",
        "poll": "ステータスをポーリング: get-approval-status \"{{approvalId}}\""
      },
      "errors": {
        "failed": "承認リクエストの作成に失敗しました: {{message}}"
      }
    },
    "refreshTasks": {
      "description": "現在の要件と設計に基づいてタスクリストを再生成します。\n\n# 使用方法\n設計変更後にタスクを更新する必要があるとき、または実装と要件の間のギャップを埋めるときに呼び出します。既存のrequirements.mdとdesign.mdを分析して包括的な更新されたタスクリストを作成します。既存のtasks.mdを更新バージョンで置き換えます。",
      "projectPathDescription": "プロジェクトルートへの絶対パス",
      "specNameDescription": "仕様の名前",
      "successMessage": "\"{{specName}}\"のタスクリフレッシュコンテキストが読み込まれました。AIエージェントがタスクを分析して更新する準備ができました。",
      "analysis": {
        "hasTasks": "\n## 現在のタスク分析\n**総タスク数**: {{total}}\n**完了**: {{completed}} (機能が削除されていてもそのまま保持)\n**進行中**: {{inProgress}} (機能が削除されていてもそのまま保持)\n**保留中**: {{pending}} (requirements.md/design.mdに対して検証)\n\n### 保持するタスク (変更しない):\n{{completedList}}\n{{inProgressList}}\n\n### 保留中のタスク (検証が必要):\n{{pendingList}}\n\n**検証が必要**: 上記の各保留中タスクについて、機能がrequirements.mdまたはdesign.mdに記載されているか確認します。記載されていない場合は、タスクを削除します。\n",
        "noTasks": "\n## 現在のタスク分析\n**tasks.mdが存在しません** - 完全なタスクリストを最初から作成する必要があります。\n",
        "none": "なし",
        "checkPrompt": "確認: この機能はrequirements.mdにありますか？"
      },
      "instructions": {
        "main": "# タスクリフレッシュ指示\n\n## コンテキスト\n実装中に要件や設計が変更された可能性があるため、仕様\"{{specName}}\"のタスクリストを更新しています。目標は、タスクリストが現在の実装と更新された要件/設計の間のギャップを埋めるために必要な作業を正確に反映することです。\n\n## 重要: 真実の源\n- **要件はrequirements.mdからのみ来ます** - 既存のタスクからではありません\n- **設計決定はdesign.mdからのみ来ます** - 既存のタスクからではありません\n- **タスクは実装ステップです** - 要件を実装し、定義しません\n- 機能がタスクに存在してもrequirements.md/design.mdに存在しない場合、それは仕様から削除されています\n\n## 3パス検証プロセス\n\n### パス1: 現在の仕様に対する既存タスクの検証\n各既存タスクについて、「このタスクが実装する機能はまだrequirements.mdまたはdesign.mdにありますか？」と尋ねます。\n\n**保留中タスクのアクション:**\n- **保持**: 機能がまだ要件/設計にある場合\n- **削除**: 機能が要件/設計にない場合（機能が仕様から削除された）\n\n**完了/進行中タスクのアクション:**\n- **保持**: 完了[x]および進行中[-]のタスクは常に保持\n- **フラグ**: 機能が削除された場合、コメントを追加: \"_注: 機能は仕様から削除されましたが、タスクは保持されました_\"\n\n### パス2: ギャップ分析\nrequirements.mdの各要件について、「これを実装するタスクはありますか？」と尋ねます。\ndesign.mdの各設計決定について、「このアーキテクチャに沿ったタスクはありますか？」と尋ねます。\n\n**アクション:**\n- **追加**: タスクなしの要件/設計要素の新しいタスク\n- **更新**: 更新された要件に合わせる必要がある既存の保留中タスク\n\n### パス3: 更新されたタスクリストの作成（変更が必要な場合のみ）\n**決定ポイント**: パス1とパス2の後、確認:\n- 削除する保留中タスクはありますか？\n- 追加する新しいタスクはありますか？\n- 変更する既存のタスクはありますか？\n\n**変更が不要な場合**: 「タスクリストは現在の要件と既に整合しています - リフレッシュは不要です」と報告して停止。\n\n**変更が必要な場合**、新しいtasks.mdを構築:\n1. すべての完了[x]タスク（そのまま保持）\n2. すべての進行中[-]タスク（該当する場合は削除メモ付きでそのまま保持）\n3. 現在の要件/設計に裏付けのある保留中[ ]タスクのみ\n4. 不足している要件/設計要素の新しいタスク\n5. 適切なシーケンスと要件参照\n\n## 重要なルール\n- 完了タスク（[x]でマーク）を**決して**変更しない\n- 進行中タスク（[-]でマーク）を**決して**変更しない\n- 現在の要件/設計にない機能の保留中タスクを**削除**\n- 特定の要件を**常に**参照（例: _要件: 1.1, 2.3_）\n- タスクが段階的に構築されることを**確保**\n- タスクをアトミック、具体的、実行可能に**作成**\n- 元のtasks.md構造を**保持** - タスク項目自体のみを更新\n- tasks.mdに追加セクションなし（依存関係、メトリクス、メモ、変更内容など）\n- tasks.mdをクリーンに**保つ** - 変更の要約はチャット応答のみ\n\n## タスク形式の要件\n各タスクはこの形式に従う必要があります:\n```\n- [ ] 1.1 ユーザー認証インターフェースの作成\n  - ファイル: src/auth/UserAuth.ts\n  - ログインと登録フォームの実装\n  - フォーム検証とエラー処理の追加\n  - 目的: ユーザーアカウント管理の有効化\n  - _活用: src/components/BaseForm.tsx, src/utils/validation.ts_\n  - _要件: 1.1, 1.2_\n```\n\n## 実装戦略\n1. requirements.mdとdesign.mdを注意深く**読む** - これらが存在すべきものを定義\n2. 現在の仕様に対して既存タスクを**検証**（パス1）\n3. タスクカバレッジのギャップを**特定**（パス2）\n4. 適切な検証で更新されたタスクリストを**構築**（パス3）\n5. create-spec-docツールを**使用**して更新されたtasks.mdを保存\n6. **重要**: tasks.mdを元と同じ形式に保つ - タスク項目のみを変更すべき\n\n## 例: 削除された機能の処理\nタスクが「かんばんビュー」のために存在するが、「かんばんビュー」がrequirements.mdに記載されていない場合:\n- 保留中[ ]かんばんタスクを**削除**\n- 完了[x]または進行中[-]かんばんタスクを**保持**\n- メモを**追加**: \"_注: かんばん機能は仕様から削除されましたが、完了した作業は保持されました_\"\n\n## 次のステップ\n以下のドキュメントを分析した後:\n1. 3パス検証プロセスを実行\n2. **決定ポイント**: 検証後に変更が不要な場合、単に「タスクは既に整合」と報告して停止\n3. **変更が必要な場合のみ**: create-spec-docツールを使用:\n   - projectPath: \"{{projectPath}}\"\n   - specName: \"{{specName}}\"\n   - document: \"tasks\"\n   - content: [検証および更新されたタスクマークダウン - 元と同じ形式]\n4. 現在の要件のみがタスクを持つことを確認\n5. タスクの依存関係と順序が意味を持つことを確認\n6. **記憶**: Tasks.mdには更新されたタスクリストのみを含める - 追加セクションなし"
      },
      "fullContext": "{{instructions}}\n\n{{taskAnalysis}}\n\n---\n\n## 要件ドキュメント\n{{requirementsContent}}\n\n---\n\n## 設計ドキュメント\n{{designContent}}\n\n---\n\n## 現在のタスクドキュメント\n{{tasksContent}}\n\n---\n\n## 要約\nタスクリストを更新するために必要なすべてのコンテキストがあります。create-spec-docツールを使用して更新されたtasks.mdを作成:\n- すべての完了（[x]）および進行中（[-]）タスクを保持（機能が削除されていても）\n- 現在のrequirements.md/design.mdにない機能の保留中（[ ]）タスクを削除\n- タスクが不足している要件/設計要素の新しいタスクを追加\n- 適切なタスクシーケンスと要件参照を確保\n- requirements.md/design.mdで実際に指定された機能を実装するタスクのみを含める\n\n**記憶**: 機能がタスクに存在してもrequirements.md/design.mdに存在しない場合、それは仕様から削除されており、保留中タスクは削除されるべきです。",
      "messages": {
        "noRequirements": "requirements.mdが見つかりません",
        "noDesign": "design.mdが見つかりません",
        "noTasks": "tasks.mdが存在しません - 最初から作成"
      },
      "nextSteps": {
        "pass1": "パス1: requirements.md/design.mdに対して各既存タスクを検証",
        "pass2": "パス2: ギャップを特定 - タスクなしの要件/設計要素を見つける",
        "decision": "決定: 変更が不要な場合、「タスクは既に整合」と報告して停止",
        "pass3": "パス3: 変更が必要な場合のみ、create-spec-docツールを使用して更新されたtasks.mdを作成"
      },
      "errors": {
        "noContext": "requirements.mdまたはdesign.mdが見つかりません。仕様コンテキストなしでタスクをリフレッシュできません。",
        "genericFail": "リフレッシュコンテキストの読み込みに失敗しました: {{message}}",
        "nextSteps": {
          "createReq": "最初にcreate-spec-docツールを使用してrequirements.mdを作成",
          "createDesign": "要件が承認された後にdesign.mdを作成",
          "thenRefresh": "その後refresh-tasksを使用して整合したタスクリストを作成",
          "checkDir": "仕様ディレクトリが存在するか確認",
          "checkPerms": "ファイル権限を確認",
          "checkName": "仕様名が正しいことを確認"
        }
      }
    },
    "getTemplateContext": {
      "description": "仕様またはステアリングドキュメントの特定のドキュメントテンプレートを読み込みます。\n\n# 使用方法\n現在のフェーズに必要な正確なテンプレートで呼び出します。仕様ワークフローでは、requirements、design、またはtasksテンプレートをリクエストします。ステアリングドキュメントでは、product、tech、またはstructureテンプレートをリクエストします。各テンプレートはcreate-spec-docまたはcreate-steering-docツールで期待される正確な形式を提供します。",
      "projectPathDescription": "プロジェクトルートへの絶対パス",
      "templateTypeDescription": "テンプレートのタイプ: ワークフローテンプレートの場合はspec、プロジェクトドキュメントの場合はsteering",
      "templateDescription": "読み込む特定のテンプレート",
      "docTitles": {
        "requirements": "要件テンプレート",
        "design": "設計テンプレート",
        "tasks": "タスクテンプレート",
        "product": "プロダクトテンプレート",
        "tech": "テクノロジーテンプレート",
        "structure": "構造テンプレート"
      },
      "successMessage": "{{templateType}}の{{template}}テンプレートを読み込みました",
      "messages": {
        "fullContext": "## {{title}}\n\n{{content}}\n\n**注**: テンプレートが読み込まれました。{{template}}ドキュメントを作成するときはこの構造を使用してください。"
      },
      "nextSteps": {
        "success": {
          "useTemplate": "{{template}}ドキュメントにテンプレートを使用",
          "followStructure": "テンプレート構造に正確に従う",
          "nextSpec": "次: document: \"{{template}}\"でcreate-spec-doc",
          "nextSteering": "次: document: \"{{template}}\"でcreate-steering-doc"
        }
      },
      "errors": {
        "invalidType": "無効なテンプレートタイプ: {{templateType}}",
        "validTypes": "使用: specまたはsteering",
        "invalidTemplateForType": "タイプ\"{{templateType}}\"に対して無効なテンプレート\"{{template}}\"",
        "validTemplates": "有効なテンプレート: {{validTemplates}}",
        "validSpecTemplates": "使用: requirements、design、またはtasks",
        "validSteeringTemplates": "使用: product、tech、またはstructure",
        "templateEmpty": "テンプレートファイルは存在しますが空です: {{file}}",
        "fileNotFound": "テンプレートファイルが見つかりません: {{file}}",
        "genericFail": "テンプレートコンテキストの読み込みに失敗しました: {{message}}",
        "nextSteps": {
          "checkContent": "テンプレートファイルの内容を確認",
          "verifyIntegrity": "ファイルの整合性を確認",
          "checkDirectory": "テンプレートディレクトリを確認",
          "verifyExists": "テンプレートファイルが存在することを確認",
          "location": "場所: {{location}}",
          "checkPermissions": "ファイル権限を確認",
          "checkFiles": "テンプレートファイルを確認"
        }
      }
    },
    "getSteeringContext": {
      "description": "アーキテクチャおよび製品コンテキストのプロジェクトステアリングドキュメントを読み込みます。\n\n# 使用方法\n既存のプロジェクトガイドライン（product.md、tech.md、structure.md）を確認するために初期仕様セットアップ中に呼び出します。新しいプロジェクトではオプションですが、確立されたコードベースでは推奨されます。ステアリングドキュメントが存在しない場合は、最初に作成するか仕様で続行するかユーザーに尋ねます。",
      "projectPathDescription": "プロジェクトルートへの絶対パス",
      "docTitles": {
        "product": "プロダクトコンテキスト",
        "tech": "テクノロジーコンテキスト",
        "structure": "構造コンテキスト"
      },
      "successMessage": "ステアリングコンテキストが正常に読み込まれました",
      "messages": {
        "notFound": "ステアリングドキュメントが見つかりません",
        "notFoundContext": "## ステアリングドキュメントコンテキスト\n\nステアリングドキュメントが見つかりません。検出された技術スタックのベストプラクティスを使用して続行します。",
        "emptyDocs": "ステアリングドキュメントは存在しますが空です",
        "emptyContext": "## ステアリングドキュメントコンテキスト\n\nステアリングドキュメントが見つかりましたが、すべて空です。",
        "fullContext": "## ステアリングドキュメントコンテキスト（プリロード済み）\n\n{{sections}}\n\n**注**: ステアリングドキュメントはプリロードされています。再度取得するためにget-contentを使用しないでください。"
      },
      "nextSteps": {
        "notFound": {
          "useBestPractices": "検出された技術スタックのベストプラクティスと規約を使用",
          "askToCreate": "確立されたコードベースの場合: プロジェクト固有のガイダンスのためにステアリングドキュメントを作成するかユーザーに尋ねる",
          "newProjectNote": "新しいプロジェクトの場合: ステアリングコンテキストは通常必要ありません - 技術のベストプラクティスで続行"
        },
        "empty": {
          "useBestPractices": "技術スタックのベストプラクティスと規約を使用",
          "askToPopulate": "確立されたコードベースの場合: プロジェクト固有のコンテキストでステアリングドキュメントを作成するかユーザーに尋ねる",
          "newProjectNote": "新しいプロジェクトの場合: 空のステアリングドキュメントは問題ありません - 標準的なプラクティスで続行"
        },
        "success": {
          "doNotCallAgain": "ステアリングコンテキストが読み込まれました - get-steering-contextを再度呼び出さない",
          "reference": "要件、設計、タスクでこれらの標準を参照",
          "align": "すべての決定が文書化されたプロジェクトビジョンと整合していることを確認"
        }
      },
      "errors": {
        "genericFail": "ステアリングコンテキストの読み込みに失敗しました: {{message}}",
        "nextSteps": {
          "checkPath": "プロジェクトパスが存在するか確認",
          "checkPermissions": "ファイル権限を確認",
          "runSetup": "ステアリングドキュメントが不足している場合はspec-steering-setupを実行"
        }
      }
    },
    "getSpecContext": {
      "description": "再開された作業のために既存の仕様ドキュメントを読み込みます。\n\n# 使用方法\n休憩後に既存の仕様の作業に戻るとき、または作成しなかった仕様で新しく開始するときのみ呼び出します。ドキュメントを作成したばかりの場合、アクティブな仕様作成中は決して使用しないでください。実装コンテキストのためにrequirements.md、design.md、tasks.mdを読み込みます。",
      "projectPathDescription": "プロジェクトルートへの絶対パス",
      "specNameDescription": "コンテキストを読み込む仕様の名前",
      "docTitles": {
        "requirements": "要件",
        "design": "設計",
        "tasks": "タスク"
      },
      "successMessage": "仕様コンテキストが正常に読み込まれました: {{specName}}",
      "messages": {
        "emptyDocs": "\"{{specName}}\"の仕様ドキュメントは存在しますが空です",
        "emptyContext": "## 仕様コンテキスト\n\n{{specName}}の仕様ドキュメントが見つかりません",
        "fullContext": "## 仕様コンテキスト（プリロード済み）: {{specName}}\n\n{{sections}}\n\n**注**: 仕様ドキュメントはプリロードされています。再度取得するためにget-contentを使用しないでください。"
      },
      "nextSteps": {
        "empty": {
          "addContent": ".spec-workflow/specs/{{specName}}/にコンテンツを追加",
          "createMissing": "不足しているドキュメントを作成",
          "ensureContent": "3つのドキュメントすべてにコンテンツがあることを確認"
        },
        "success": {
          "proceed": "コンテキストが読み込まれました - 実装を続行",
          "reference": "各タスクの要件と設計を参照",
          "updateStatus": "manage-tasksでタスクステータスを更新"
        }
      },
      "errors": {
        "notFound": "{{specName}}の仕様が見つかりません",
        "availableSpecs": "利用可能な仕様: {{specs}}",
        "genericFail": "仕様コンテキストの読み込みに失敗しました: {{message}}",
        "nextSteps": {
          "useExisting": "既存の仕様名を使用",
          "createNew": "またはcreate-spec-docで新規作成",
          "create": "create-spec-docで仕様を作成",
          "checkSpelling": "仕様名のスペルを確認",
          "verifySetup": "プロジェクトセットアップを確認",
          "checkPath": "プロジェクトパスを確認",
          "verifyName": "仕様名を確認",
          "checkPermissions": "ファイル権限を確認",
          "createIfMissing": "不足している場合は仕様を作成"
        }
      }
    },
    "getApprovalStatus": {
      "description": "承認リクエストの現在のステータスを確認します。\n\n# 使用方法\nrequest-approvalの後にユーザーの決定をポーリングするために呼び出します。ステータスが\"approved\"または\"needs-revision\"になるまで確認を続けます。needs-revisionの場合、フィードバックをレビューし、create-spec-docでドキュメントを更新し、新しい承認リクエストを作成します。\"approved\"ステータスの後のみ次のフェーズに進みます。",
      "projectPathDescription": "プロジェクトルートへの絶対パス（提供されない場合はコンテキストを使用）",
      "approvalIdDescription": "確認する承認リクエストのID",
      "messages": {
        "pending": "ブロック: ステータスは{{status}}です。口頭での承認は受け入れられません。ダッシュボードまたはVS Code拡張機能のみを使用してください。",
        "other": "承認ステータス: {{status}}"
      },
      "nextSteps": {
        "pending": {
          "blocked": "ブロック - 続行しない",
          "noVerbal": "口頭での承認は受け入れられません - ダッシュボードまたはVS Code拡張機能のみを使用",
          "useUI": "承認はダッシュボードまたはVS Code拡張機能経由で行う必要があります",
          "poll": "get-approval-statusでポーリングを続行"
        },
        "approved": {
          "canProceed": "承認済み - 続行可能",
          "delete": "続行前にdelete-approvalを実行",
          "response": "応答: {{response}}"
        },
        "rejected": {
          "blocked": "ブロック - 拒否",
          "doNotProceed": "続行しない",
          "revise": "フィードバックをレビューして修正",
          "reason": "理由: {{reason}}",
          "notes": "メモ: {{notes}}"
        },
        "needsRevision": {
          "blocked": "ブロック - 続行しない",
          "update": "フィードバックでドキュメントを更新",
          "newRequest": "新しい承認リクエストを作成",
          "feedback": "フィードバック: {{feedback}}",
          "notes": "メモ: {{notes}}",
          "comments": "ターゲット修正のための{{count}}コメント"
        }
      },
      "errors": {
        "projectPathRequired": "プロジェクトパスが必要です。projectPathパラメータを提供してください。",
        "notFound": "承認リクエストが見つかりません: {{approvalId}}",
        "genericFail": "承認ステータスの確認に失敗しました: {{message}}"
      }
    },
    "deleteApproval": {
      "description": "完了した承認リクエストをシステムからクリーンアップします。\n\n# 使用方法\n\"approved\"ステータスを受け取った直後に呼び出します。承認の混乱を防ぐための重要なクリーンアップステップです。次のワークフローフェーズに移る前に完了する必要があります。将来のリクエストのために承認システムを整理しておきます。",
      "projectPathDescription": "プロジェクトルートへの絶対パス（提供されない場合はコンテキストを使用）",
      "approvalIdDescription": "削除する承認リクエストのID",
      "successMessage": "承認リクエスト\"{{approvalId}}\"が正常に削除されました",
      "nextSteps": {
        "cleanupComplete": "クリーンアップ完了",
        "continue": "次のフェーズに続行"
      },
      "errors": {
        "projectPathRequired": "プロジェクトパスが必要です。projectPathパラメータを提供してください。",
        "notFound": "承認リクエスト\"{{approvalId}}\"が見つかりません",
        "notApproved": "ブロック: 続行できません - ステータスは\"{{status}}\"です。口頭での承認は受け入れられません。ダッシュボードまたはVS Code拡張機能を使用してください。",
        "deleteFailed": "承認リクエスト\"{{approvalId}}\"の削除に失敗しました",
        "genericFail": "承認の削除に失敗しました: {{message}}",
        "nextSteps": {
          "verifyId": "承認IDを確認",
          "checkStatus": "get-approval-statusでステータスを確認",
          "stop": "停止 - 次のフェーズに進まない",
          "wait": "承認を待つ",
          "poll": "get-approval-statusでポーリング",
          "checkPermissions": "ファイル権限を確認",
          "verifyExists": "承認が存在することを確認",
          "retry": "再試行",
          "checkPath": "プロジェクトパスを確認",
          "checkSystem": "承認システムを確認"
        }
      }
    },
    "createSteeringDoc": {
      "description": "アーキテクチャガイダンスを含むプロジェクトステアリングドキュメントを作成します。\n\n# 使用方法\nユーザーがステアリングドキュメントの作成を明示的に承認した後のみ呼び出します。仕様ワークフローには必要ありません。次のいずれかを作成: product.md（ビジョン/目標）、tech.md（技術的決定）、またはstructure.md（コードベース組織）。最初にsteering-guideを使用してテンプレートを取得します。",
      "projectPathDescription": "プロジェクトルートへの絶対パス",
      "documentDescription": "作成するステアリングドキュメント: product、tech、またはstructure",
      "contentDescription": "ステアリングドキュメントの完全なマークダウンコンテンツ",
      "docNames": {
        "product": "プロダクトステアリング",
        "tech": "技術ステアリング",
        "structure": "構造ステアリング"
      },
      "successMessage": "{{docName}}ドキュメントが正常に作成されました",
      "nextSteps": {
        "saved": "{{filename}}を保存しました",
        "product": "次: tech.mdを作成",
        "tech": "次: structure.mdを作成",
        "structure": "ステアリング完了。category:\"steering\"とcategoryName:\"steering\"でrequest-approvalを使用",
        "dashboard": "ダッシュボード: {{dashboardUrl}}",
        "dashboardUnavailable": "ダッシュボードは利用できません"
      },
      "errors": {
        "failed": "{{document}}ステアリングドキュメントの作成に失敗しました: {{message}}",
        "nextSteps": {
          "checkPath": "プロジェクトパスが存在するか確認",
          "verifyContent": "マークダウンコンテンツを確認",
          "retry": "正しいパラメータで再試行"
        }
      }
    },
    "createSpecDoc": {
      "description": "ワークフローシーケンスに従って仕様ドキュメントを作成または更新します。\n\n# 使用方法\nテンプレートを読み込み、各フェーズのコンテンツを生成した後に呼び出します。一度に1つのドキュメントを作成: 最初にrequirements、次にdesign、最後にtasks。各ドキュメント間でユーザー承認なしに複数のドキュメントを作成しないでください。常にget-template-contextからのテンプレート構造に従います。",
      "projectPathDescription": "プロジェクトルートへの絶対パス",
      "specNameDescription": "ケバブケースの機能名（例: user-authentication）",
      "documentDescription": "作成/更新する仕様ドキュメント: requirements、design、またはtasks",
      "contentDescription": "仕様ドキュメントの完全なマークダウンコンテンツ",
      "errors": {
        "designBeforeReq": "ワークフロー違反: requirements.mdが存在する前にdesign.mdを作成できません！\n最初にrequirements.mdを作成し、ユーザーレビューを取得し、その後design.mdを作成してください。",
        "tasksBeforeDesign": "ワークフロー違反: design.mdが存在する前にtasks.mdを作成できません！\n最初にdesign.mdを作成し、ユーザーレビューを取得し、その後tasks.mdを作成してください。",
        "failed": "失敗しました: {{message}}"
      },
      "successMessage": "{{filename}}を作成しました: {{filePath}}\n\nブロッキング: ダッシュボードまたはVS Code拡張機能経由で承認をリクエストする必要があります。\n口頭での承認は受け入れられません。\nシステムが承認ステータスを表示するまで続行しないでください。"
    },
    "specWorkflowGuide": {
      "description": "アイデアから実装まで機能開発をガイドする重要な仕様ワークフロー指示を読み込みます。\n\n# 使用方法\nユーザーが仕様作成、機能開発、または仕様について言及したときに最初にこのツールを呼び出します。これは従わなければならない完全なワークフローシーケンス（要件→設計→タスク→実装）を提供します。適切なワークフロー理解を確実にするために、他の仕様ツールの前に常に読み込みます。",
      "dashboardMessage": "ダッシュボードで進捗を監視: {{dashboardUrl}}",
      "dashboardUnavailable": "ダッシュボードは利用できません - ヘッドレスモードで実行中",
      "successMessage": "完全な仕様ワークフローガイドが読み込まれました - このワークフローに正確に従ってください",
      "nextSteps": {
        "step1": "シーケンスに従う: 要件→設計→タスク→実装",
        "step2": "最初にget-template-contextでテンプレートを読み込む",
        "step3": "各ドキュメント後に承認をリクエスト",
        "step4": "MCPツールのみを使用"
      },
      "guide": "# 仕様開発ワークフロー\n\n## 概要\n\nMCPツールを使用して仕様駆動開発を通じてユーザーをガイドします。要件→設計→タスク→実装フェーズを通じて粗いアイデアを詳細な仕様に変換します。利用可能な場合は現在のベストプラクティスのためにウェブ検索を使用します。\n\n機能名はケバブケースを使用（例: user-authentication）。一度に1つの仕様を作成。\n\n## ワークフロー図\n```mermaid\nflowchart TD\n    Start([開始: ユーザーが機能をリクエスト]) --> CheckSteering{ステアリングドキュメントは存在？}\n    CheckSteering -->|Yes| P1_Load[get-steering-context]\n    CheckSteering -->|No| P1_Template\n    \n    %% フェーズ1: 要件\n    P1_Load --> P1_Template[get-template-context<br/>templateType: spec<br/>template: requirements]\n    P1_Template --> P1_Research[利用可能な場合はウェブ検索]\n    P1_Research --> P1_Create[create-spec-doc<br/>document: requirements]\n    P1_Create --> P1_Approve[request-approval<br/>filePathのみ]\n    P1_Approve --> P1_Status[get-approval-status<br/>ステータスをポーリング]\n    P1_Status --> P1_Check{ステータス？}\n    P1_Check -->|needs-revision| P1_Update[ユーザーコメントをガイダンスとしてドキュメントを更新]\n    P1_Update --> P1_Create\n    P1_Check -->|approved| P1_Clean[delete-approval]\n    P1_Clean -->|failed| P1_Status\n    \n    %% フェーズ2: 設計\n    P1_Clean -->|success| P2_Template[get-template-context<br/>templateType: spec<br/>template: design]\n    P2_Template --> P2_Analyze[コードベースパターンを分析]\n    P2_Analyze --> P2_Create[create-spec-doc<br/>document: design]\n    P2_Create --> P2_Approve[request-approval<br/>filePathのみ]\n    P2_Approve --> P2_Status[get-approval-status<br/>ステータスをポーリング]\n    P2_Status --> P2_Check{ステータス？}\n    P2_Check -->|needs-revision| P2_Update[ユーザーコメントをガイダンスとしてドキュメントを更新]\n    P2_Update --> P2_Create\n    P2_Check -->|approved| P2_Clean[delete-approval]\n    P2_Clean -->|failed| P2_Status\n    \n    %% フェーズ3: タスク\n    P2_Clean -->|success| P3_Template[get-template-context<br/>templateType: spec<br/>template: tasks]\n    P3_Template --> P3_Break[設計をタスクに変換]\n    P3_Break --> P3_Create[create-spec-doc<br/>document: tasks]\n    P3_Create --> P3_Approve[request-approval<br/>filePathのみ]\n    P3_Approve --> P3_Status[get-approval-status<br/>ステータスをポーリング]\n    P3_Status --> P3_Check{ステータス？}\n    P3_Check -->|needs-revision| P3_Update[ユーザーコメントをガイダンスとしてドキュメントを更新]\n    P3_Update --> P3_Create\n    P3_Check -->|approved| P3_Clean[delete-approval]\n    P3_Clean -->|failed| P3_Status\n    \n    %% フェーズ4: 実装\n    P3_Clean -->|success| P4_Ready[仕様完了。<br/>実装の準備は？]\n    P4_Ready -->|Yes| P4_Status[spec-status]\n    P4_Status --> P4_Task[manage-tasks<br/>action: set-status<br/>status: in-progress]\n    P4_Task --> P4_Code[コードを実装]\n    P4_Code --> P4_Complete[manage-tasks<br/>action: set-status<br/>status: completed]\n    P4_Complete --> P4_More{タスクはまだある？}\n    P4_More -->|Yes| P4_Task\n    P4_More -->|No| End([実装完了])\n    \n    style Start fill:#e1f5e1\n    style End fill:#e1f5e1\n    style P1_Check fill:#ffe6e6\n    style P2_Check fill:#ffe6e6\n    style P3_Check fill:#ffe6e6\n    style CheckSteering fill:#fff4e6\n    style P4_More fill:#fff4e6\n```\n\n## 仕様ワークフロー\n\n### フェーズ1: 要件\n**目的**: ユーザーニーズに基づいて何を構築するかを定義。\n\n**ツール**:\n- get-steering-context: プロジェクトガイドラインを確認（確立されたコードベースの場合）\n- get-template-context: 要件テンプレートを読み込む (templateType: \"spec\", template: \"requirements\")\n- create-spec-doc: requirements.mdを作成\n- request-approval: ユーザー承認を取得\n- get-approval-status: 承認ステータスを確認\n- delete-approval: 承認後のクリーンアップ\n\n**プロセス**:\n1. ステアリングドキュメントを確認（確立されたコードベースの場合は作成するかユーザーに尋ねる）\n2. 要件テンプレートを読み込む\n3. 市場/ユーザー期待を調査（ウェブ検索が利用可能な場合）\n4. EARS基準でユーザーストーリーとして要件を生成\n5. create-spec-docでドキュメントを作成\n6. 承認をリクエスト（filePathのみ、コンテンツは決して含めない）\n7. approved/needs-revisionまでステータスをポーリング（口頭での承認は決して受け入れない）\n8. needs-revisionの場合: ドキュメントを更新、新しい承認を作成、続行しない\n9. 承認されたら: 続行前にdelete-approval（成功しなければならない）\n10. delete-approvalが失敗した場合: 停止 - ポーリングに戻る\n\n### フェーズ2: 設計\n**目的**: すべての要件に対応する技術設計を作成。\n\n**ツール**:\n- get-template-context: 設計テンプレートを読み込む (templateType: \"spec\", template: \"design\")\n- create-spec-doc: design.mdを作成\n- request-approval: ユーザー承認を取得\n- get-approval-status: ステータスを確認\n- delete-approval: クリーンアップ\n\n**プロセス**:\n1. 設計テンプレートを読み込む\n2. 再利用するパターンのコードベースを分析\n3. 技術選択を調査（ウェブ検索が利用可能な場合）\n4. すべてのテンプレートセクションで設計を生成\n5. ドキュメントを作成し承認をリクエスト\n6. approved/needs-revisionまでステータスをポーリング\n7. needs-revisionの場合: ドキュメントを更新、新しい承認を作成、続行しない\n8. 承認されたら: 続行前にdelete-approval（成功しなければならない）\n9. delete-approvalが失敗した場合: 停止 - ポーリングに戻る\n\n### フェーズ3: タスク\n**目的**: 設計をアトミックな実装タスクに分解。\n\n**ツール**:\n- get-template-context: タスクテンプレートを読み込む (templateType: \"spec\", template: \"tasks\")\n- create-spec-doc: tasks.mdを作成\n- request-approval: ユーザー承認を取得\n- get-approval-status: ステータスを確認\n- delete-approval: クリーンアップ\n\n**プロセス**:\n1. タスクテンプレートを読み込む\n2. 設計をアトミックタスク（各1-3ファイル）に変換\n3. ファイルパスと要件参照を含める\n4. ドキュメントを作成し承認をリクエスト\n5. approved/needs-revisionまでステータスをポーリング\n6. needs-revisionの場合: ドキュメントを更新、新しい承認を作成、続行しない\n7. 承認されたら: 続行前にdelete-approval（成功しなければならない）\n8. delete-approvalが失敗した場合: 停止 - ポーリングに戻る\n9. 成功したクリーンアップ後: 「仕様完了。実装の準備はできましたか？」\n\n### フェーズ4: 実装\n**目的**: タスクを体系的に実行。\n\n**ツール**:\n- spec-status: 全体的な進捗を確認\n- manage-tasks: タスクステータスを追跡および更新\n- get-spec-context: 作業に戻る場合は仕様を読み込む\n\n**プロセス**:\n1. spec-statusで現在のステータスを確認\n2. 各タスクについて:\n   - manage-tasks action: \"set-status\", status: \"in-progress\"\n   - コードを実装\n   - manage-tasks action: \"set-status\", status: \"completed\"\n3. すべてのタスクが完了するまで続行\n\n## ワークフロールール\n\n- 常にMCPツールを使用、手動でドキュメントを作成しない\n- 正確なテンプレート構造に従う\n- フェーズ間で明示的なユーザー承認を取得\n- フェーズを順番に完了（スキップなし）\n- 一度に1つの仕様\n- 仕様名にケバブケースを使用\n- 承認リクエスト: filePathのみを提供、コンテンツは決して含めない\n- ブロッキング: delete-approvalが失敗した場合は決して続行しない\n- 重要: 次のフェーズの前に承認ステータスと成功したクリーンアップが必要\n- 重要: 口頭での承認は決して受け入れられない - ダッシュボードまたはVS Code拡張機能のみ\n- ユーザーが「承認」と言っても決して続行しない - システムステータスのみを確認\n- ステアリングドキュメントはオプション - 明示的に要求された場合のみ作成"
    }
  }
}